1.首先要说下 Java 内存模型的抽象，JMM 规定了每个线程都有自己的本地内存，本地内存中存放的是主内存中
共享变量的拷贝. 现在线程 A 需要和线程 B 通讯，则需要通过 A 的本地内存，在 JMM 的控制下，到主内存，
然后从主内存到线程 B 的本地内存，这样就完成了一次通讯.

2.现代编译器为了提高提高性能，会对指令进行重排序. 重排序分为 3 类重排序.
(1)编译器优化的重排序
(2)指令级并行的重排序
(3)内存系统的重排序

因为重排序的问题，我们在编程的时候，是不是会碰到各种莫名其妙的问题？例如 i++，初始时 i=0，但是最终
两个线程的执行结果是不是都是 1?

为了解决可见性问题，Java 有如下策略：

(1)内存屏障
(2)happens-before
    1.一个线程中的每个操作，happens-before 于该线程中的任意后续操作
    2.对于一个锁的解锁，happens-before 与随后对这个锁的加锁
    3.对一个 volatile 域的写，happens-before 与任务后续对这个 volatile 域的读.
    4.A happens-before B, B happens-before C, 那么 A happens-before C.
注意：happens-before 并不意味着一个操作必须先于另一个操作执行，而是说那个操作的结果对后一个操作可见.

对于有数据依赖关系的操作，单线程中是不会进行重排序的，但是在多线程中，数据依赖不被编译器考虑.

有数据依赖关系的：

读后写
写后读
写后写

3.as-if-serial 语义
as-if-serial 语义是说不管怎么重排序，单线程程序的执行结果不能被改变.
