1.首先要说下 Java 内存模型的抽象，JMM 规定了每个线程都有自己的本地内存，本地内存中存放的是主内存中
共享变量的拷贝. 现在线程 A 需要和线程 B 通讯，则需要通过 A 的本地内存，在 JMM 的控制下，到主内存，
然后从主内存到线程 B 的本地内存，这样就完成了一次通讯.

2.现代编译器为了提高提高性能，会对指令进行重排序. 重排序分为 3 类重排序.
(1)编译器优化的重排序
(2)指令级并行的重排序
(3)内存系统的重排序

因为重排序的问题，我们在编程的时候，是不是会碰到各种莫名其妙的问题？例如 i++，初始时 i=0，但是最终
两个线程的执行结果是不是都是 1?

为了解决可见性问题，Java 有如下策略：

(1)内存屏障
(2)happens-before
    1.一个线程中的每个操作，happens-before 于该线程中的任意后续操作
    2.对于一个锁的解锁，happens-before 与随后对这个锁的加锁
    3.对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读.
    4.A happens-before B, B happens-before C, 那么 A happens-before C(传递性).
    
注意：happens-before 并不意味着一个操作必须先于另一个操作执行，而是说那个操作的结果对后一个操作可见.

对于有数据依赖关系的操作，单线程中是不会进行重排序的，但是在多线程中，数据依赖不被编译器考虑.

有数据依赖关系的：

读后写
写后读
写后写

3.as-if-serial 语义
as-if-serial 语义是说不管怎么重排序，单线程程序的执行结果不能被改变.

4.顺序一致性模型
顺序一致性模式是一个理论的参考模型，它为程序员提供了极强的内存可见性保证. 顺序一致性模型有两大特点：
**(1) 一个线程中的所有操作都是按照顺序的先后顺序执行的.
(2) 不管程序是否同步，所有线程都只能看到一个单一的操作顺序. 顺序一致性模型中，所有的操作都必须原子执行且立刻对所有线程可见.**

那顺序一致性模型是怎么实现的了？

理论上，顺序一致性模式有一个全局的内存，这个内存有一个开关，可以连接到任意的线程上(就像我们在物理中学到的单刀开关一样，将开关拨到
左边，左边的灯亮，将开关拨到右边，右边的灯亮). 所以在任意的时间点上，只会有一个线程可以连接到内存，进行读写操作. 当多个线程并发读写
时，按照这么一套逻辑，将会被串行化.

根据上面的定义：

来举一个例子：

假设有线程A和线程B两个线程，线程A中有三个操作，A1，A2，A3
线程B中也有三个操作，B1，B2，B3.

现在假设使用同步的话，先执行A线程，后执行B线程. 那么看到的执行顺序是：
A1->A2->A3->B1->B2->B3

如果不使用同步的话，执行顺序可能是：
A1->B1->A2->B2->A3->B3

虽然整体上无序，但是对于线程A或线程B而言，还是有序的.

注：**这里说的单一操作顺序，不是说还有一种执行情况：
B1->A1->A2->B2->A3->B3
而是说的每个操作对其他线程可见. 换句话说，一个线程对一个变量进行了修改，那么另一个线程可以看到这个修改后的值，这和JMM不同. JMM 中，
如果修改了某个值，不一定对其他线程可见(还没有刷新会主存)，所以其他线程是看不到这个线程做的修改(也就是不可见)，换句话说，两个线程看到
的操作顺序不是单一的**.


**所以在 JMM 中，如果不小心的话，就会出现内存可见性问题，执行结果会和预期不一致.
因为在 JMM 中，未同步的程序不但整体无序，而且执行顺序也是无序的，而且所欲线程看到的在线顺序也可能不一致(正如上面所说).**

测试用例：
-----------------------------------------------------------
public class SyncTest {
    int a=0;
    boolean flag = false;

    public synchronized void writer(){
        a = 1;
        flag = true;
    }

    public synchronized void reader(){

        if(flag){
            int i = a;
            System.out.println("i = " + i);
        }
    }

    @Test
    public void test(){
        final SyncTest syncTest = new SyncTest();

        for(int i=0; i<100; i++){
            new Thread(new Runnable() {
                public void run() {
                    syncTest.writer();
                }
            }).start();

            new Thread(new Runnable() {
                public void run() {
                    syncTest.reader();
                }
            }).start();
        }
    }

}


发现最终结果是 100 个 1.
从结果中可以得出如下结论：
正确同步的程序，执行结果和程序在顺序一致性模型中的执行结果相同.

是不是有一个疑问：在线程1 中对变量 a 的修改的结果反映到线程2 中了. 这是为什么了？
变量 a 只是一个普通的 int 类型，又不是 volatile 修饰的(强制刷新到主存).
这个就要说到 JMM 内存模型了，线程中的工作内存拿到的是主存中变量的拷贝. 所以线程 1 和线程 2拿到的都是拷贝(实际对象在堆内存中).
所以当在线程1中进行修改的时候，直接返回到堆上了，所以线程2能够可见.

对于未同步或未正确同步的多线程程序，JMM 只提供最小的安全性. 即线程读取到的值，不会凭空出现(要么是默认值，要么是其他线程写入的值).

还有一点要说明的是，JMM 不保证对 64 位的 long 和 double 类型变量的写入操作具有原子性(针对 32 位机器).

原因：与处理器总线的工作机制有关. 总线是沟通内存和处理器的桥梁. 总线事务分为读事务和写事务. 其实多 CPU 同个总线连接内存和我们上面
讲的单刀双掷开关很像. 当多个 CPU 同时发起总线事务时，总线会通过仲裁，判定那个 CPU 获得访问内存的权利. 而其他处理器则需要等待.
换句话说，在任意时刻，只有一个 CPU 能够访问内存.

在 32 位机器上，如果要保证对 64 位数据类型的写操作具有原子性，开销较大. 所以 Java 语言规范不强求 JVM 对 64 位数据类型的写
操作具有原子性.

当处理器在处理 64 位的写操作，可能会拆分为两个 32 为的写操作. 当一个处理器将高位写入的时候，可能另一个处理器读取到了一个不合法
的数(无效值).


5.
