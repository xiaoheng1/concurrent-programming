内存屏障：

LoadLoad:
    Load1; LoadLoad; Load2 保证 Load1 指令在 Load2 及其后续指令加载前完成加载   
StoreStore:
    Store1; StoreStore; Store2 保证 Store1 指令对其他处理器可见，先于 Store2 指令及其后续存储指令的存储
LoadStore:
    Load1; LoadStore; Store2 保证 Load1 指令装载，先于 Store1 指令及其后续存储指令刷新进入主内存 
StoreLoad:
    Store1; StoreLoad; Load1 保证 Store1 指令对其他处理器可见，之前于 Load1 及后续装载指令的装载



缓冲行：缓冲行从主存中加载数据，不是一个数据一个数据读取的，而是加载一个缓冲行的数据. 通常现在 64 位
的机器缓冲行为 64 字节. 所以当我们遍历数组的时候，速度就会很快，因为我们加载一次，后面的 7 个数组元素
都会命中.

所有有时候我们会看到 Java 并发包下的代码会这么写.

class Main{
    long p1, p2,
}

volatile 变量早在转成汇编时会多出一行指令

lock add1 ...

lock 前缀的指令在多核处理下回引发两件事：
1.将当前处理器缓存行里的数据写会到系统内存
2.这个写回内存操作会使在其他CPU 里缓存了该内存地址的数据无效

缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理
器的缓存行设置成无效状态, 当该处理器对这个数据进行修改擦走时，会重新从系统内存中把数据读到处理器缓存里.